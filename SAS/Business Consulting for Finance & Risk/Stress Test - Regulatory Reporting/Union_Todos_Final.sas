/*PASO 1: SE UNEN TODAS LAS TABLAS DE SALIDA DE LOS PROCESOS ANTERIORES*/
DATA SALIDA_FINAL_2017_CONTR_1;
FORMAT C1014 $2.;
FORMAT C1010 $2.;
FORMAT C0000 $18.;
FORMAT C0001 $3.;
FORMAT G030 $2.;
FORMAT CTA_CONTABLE $15.;
FORMAT SEGMENTO_FINREP $3.;
FORMAT PROD_DEPOSITOS $3.;
FORMAT PROD_EMIRF $2.;
FORMAT PROD_DERIVADOS $2.;

SET 
	CRTotal_Salida_Final_2017_contr
	DEPOSITOS_STRESS_2017_CONTR
	EMISIONES_STRESS_2017_CONTR
/*	CTAS_STRESS_2017_CONTR*/ /*las CTAs ahora estan incluidas en Depositos, son las repos: 040*/
	DERIVADOS_STRESS_2017_CONTR

	/*ANADIMOS LAS OPERATIVAS NO VIVAS PERO QUE APORTARON AL MARGEN DEL ANIO*/
	NO_VIVAS_STRESS_2017_CONTR
; 
RUN;




/*El Margen debera estar reportado con el tipo de cambio medio anual
de Holding*/
/*Regresamos el margen a Soles*/
proc sql;
	create table SALIDA_2017_CONTR_TC_1
	(drop=C0067)as
		select a.*, a.C0067*b.Tipo_Cambio as C0067_Sol
			from SALIDA_FINAL_2017_CONTR_1 a, 
			(select Tipo_Cambio from &bibliotecaInputs..Tipo_De_Cambio where Divisa="EUR") b;
quit;

/*Ahora Se usa el tipo de cambio medio anual de Holding para pasar a Euros*/
proc sql;
	create table SALIDA_2017_CONTR_TC_2
	(drop=C0067_Sol)as
		select *, C0067_Sol/&Tipo_Cambio_Prom as C0067
			from SALIDA_2017_CONTR_TC_1;
quit;









/*Fecha vencimiento por defecto*/
data SALIDA_FINAL_2017_VENCIM;
set SALIDA_2017_CONTR_TC_2;
	/*Si la fecha de vencimiento es nula, dias tambien debe ser nulo*/
	if(c0050 = input("31129999",ddmmyy8.)) then
		do;
			dias = .;
			c0050 = .;
		end;
run;


/*Se carga la fecha de apertura actualizada para los contratos que tienen
fecha apertura despues de la fecha de vencimiento (Legal)
Porque sino se tienen dias < 0 (distancia fecha apertura - vencimiento)*/
proc sql;
	create table SALIDA_FINAL_2017_APERT as
		select a.*, input(b.FECALTA,yymmdd10.) as apert_aux format = date10.
			from SALIDA_FINAL_2017_VENCIM a left join &biblioteca..contr_cliente_ifrs b
				on a.C0000 = b.contrato;
quit;


/*205 casos que aun tienen DIAS negativo*/
/*7445076*/
data SALIDA_FINAL_2017_APERT2;
set SALIDA_FINAL_2017_APERT;
	if (INDOPERVIVA = "V" AND Instrumento IN ("02","05")) then
		do;
		/*Si fecha de apertura es mayor a la fecha vencimiento*/
			if (dias <= 0 AND dias ne .) then
				do;
					c0039 = apert_aux; /*Actualizamos la fecha apertura*/
					dias = c0050 - C0039; /*Se actualiza dias*/
				end;
		end;
run;

/*Los 205 casos de negativos se mandan a .
Para evitar VOPs incoherentes*/
data SALIDA_FINAL_2017_APERT3;
set SALIDA_FINAL_2017_APERT2;
	if (dias <= 0 AND dias ne .) then
		do;
			dias = .;
		end;
run;



/*Comentado momentaneamente:*/
/*%borrarTabla(CRTotal_Salida_Final_2017_contr);*/
/*%borrarTabla(DEPOSITOS_STRESS_2017_CONTR);*/
/*%borrarTabla(EMISIONES_STRESS_2017_CONTR);*/
/*%borrarTabla(CTAs_STRESS_2017_CONTR);*/
/*%borrarTabla(DERIVADOS_STRESS_2017_CONTR);*/
/*%borrarTabla(No_Vivas_STRESS_2017_CONTR);*/



/*
Cuando se trajo el SALDO MEDIO y el MARGEN FINANCIERO de Inventarios MIS a ST,
se hizo a nivel de contrato y cuenta contable y como los reportes de liquidez tenian registros 
repetidos a nivel de contrato y cuenta contable, ENTONCES se enriquecio varias veces 
el mismo saldo medio e ingresos/gastos,
Ahora que se debe agrupar a nivel de contrato y cuenta contable, NECESITO PRORRATEAR PREVIAMENTE
al margen y al saldo medio, para no repetir en la suma.

Con esta agrupacion-suma se deberia llegar a los saldos iniciales tomados de inventarios MIS
*/

/*PASO 2: SE AGRUPA A NIVEL CONTRATO Y CUENTA CONTABLE, Y SE PRORRATEA*/
/*PASO 2.1: SE AGRUPA A NIVEL CONTRATO Y CTA CONTABLE*/
PROC SQL;
CREATE TABLE PRORATEO_SM_IG (DROP = C0041 C0067) AS
	SELECT A.*, 
	(CASE WHEN C0016 NOT IN (0,.) THEN 
	(C0041*C0016)/SUM(C0016) ELSE C0041 END) AS C0041_PRORAT,
	(CASE WHEN C0016 NOT IN (0,.) THEN 
	(C0067*C0016)/SUM(C0016) ELSE C0067 END) AS C0067_PRORAT
		FROM SALIDA_FINAL_2017_APERT3 A
			GROUP BY C0000, CTA_CONTABLE;
RUN;

/*PASO 2.2: SE PRORRATEA SALDO MEDIO Y MARGEN FINANCIERO*/
PROC SQL;
	CREATE TABLE SALIDA_FINAL_2017_CONTR_1_CUA0 AS  
		SELECT C0000,C0001,C0005,
			SUM(C0016) AS C0016,C0019,
			C0020,C0021,C0022,C0023,C0024,C0025,

/*Las operativas no vivas no tienen saldo para ponderar, entonces
	se hace un ponderado aritmetico. Por otro lado, para los 
	derivados se debe usar el nocional*/
			(SUM(C0026*abs(C0016))/SUM(abs(C0016))) AS C0026_SP,
			(SUM(C0026*abs(C0068))/SUM(abs(C0068))) AS C0026_NOC,
			(SUM(C0026)/COUNT(C0026)) AS C0026_NOVIV,



			C0027,
			(SUM(C0028*C0016)/SUM(C0016)) AS C0028,
			(SUM(C0029*C0016)/SUM(C0016)) AS C0029,
			C0030,MAX(C0038) AS C0038 FORMAT = DATE10.,
			MIN(C0039) AS C0039 FORMAT = DATE10. ,
			MAX(C0040) AS C0040 FORMAT = DATE10. ,

			SUM(C0041_PRORAT) AS C0041,

			MAX(C0050) AS C0050 FORMAT = DATE10. ,C0052, 

			SUM(C0067_PRORAT) AS C0067,

			SUM(C0068) AS C0068,C0900,C0901,C0973,C1010, C1014,

			CUENTA_NEOCON,CTA_CONTABLE,	MAX(PLAZOREF) AS PLAZOREF, 
			INSTRUMENTO, SEGMENTO_FINREP, PROD_PRESTAMOS, 
			PROD_DEPOSITOS, PROD_EMIRF, PROD_DERIVADOS, 
			INDNEWBUS, INDOPERVIVA, INDMATBUS, MAX(DIAS) AS DIAS,
			MARCA_INTERGRUPO
			FROM  PRORATEO_SM_IG 
			GROUP BY C0000, C0001,C0005,C0019,C0020,C0021,C0022,
					C0023,C0024,C0025, C0027,C0030,C0052,C0900,
					C0901,C0973, C1010,C1014,
					CUENTA_NEOCON,CTA_CONTABLE,INSTRUMENTO,SEGMENTO_FINREP,
					PROD_PRESTAMOS, PROD_DEPOSITOS, PROD_EMIRF, PROD_DERIVADOS,
					INDNEWBUS, INDOPERVIVA, INDMATBUS, MARCA_INTERGRUPO;
QUIT;

/*Tipo de Interes*/
DATA SALIDA_FINAL_2017_CONTR_1_CUA1(drop=C0026_NOVIV C0026_NOC C0026_SP);
SET SALIDA_FINAL_2017_CONTR_1_CUA0;
	IF (INDOPERVIVA = "F") then /*Operativas no Vivas*/
		C0026 = C0026_NOVIV;
		ELSE IF (INSTRUMENTO IN ("04","08")) then /*Derivados con Nocional*/
		C0026 = C0026_NOC;
	ELSE /*El resto con saldo medio*/
		C0026 = C0026_SP;
RUN;


/*test CUADRE CONTABLE VS B29*/

/*pasamos de EUROS a SOLES y mileamos*/
/*Proc sql;*/
/*	create table ST_SolesMilead as*/
/*		select a.*, (a.C0016*b.Tipo_Cambio)/1000 as Saldo_Soles*/
/*			from SALIDA_FINAL_2017_CONTR_1_CUA1 a,*/
/*				(select Tipo_Cambio from &bibliotecaInputs..Tipo_De_Cambio where Divisa="EUR") b;*/
/*quit;*/
/**/
/*proc sql;*/
/*	create table CuadreContST as*/
/*		select Cuenta_NEOCON, cta_contable, sum(Saldo_Soles) as Saldo_ST*/
/*			from ST_SolesMilead*/
/*				group by 1,2;*/
/*quit;*/

			
/*saldos B29 en soles y en este caso mileados*/
/*proc sql; */
/*	create table B29Saldos as*/
/*		select CtaGestionBBV as NeoconB29, Ctacontable as CuentaB29, sum(Saldo_B29) as SaldoB29*/
/*			from &biblioteca..B29_Saldo_Agrup*/
/*					group by 1,2;*/
/*quit;*/
/**/
/*	*/
/*proc sql;*/
/*	create table CuadreCta1 as*/
/*		select a.*, b.Cuenta_NEOCON as NeoconST, b.cta_contable as CuentaST, b.Saldo_ST*/
/*			from B29Saldos a LEFT JOIN CuadreContST b*/
/*				on a.NeoconB29 = b.Cuenta_NEOCON AND a.CuentaB29 = b.cta_contable*/
/*where a.NeoconB29 in (select distinct Cuenta_NEOCON from CuadreContST);*/
/*quit;*/
/**/
/**/
/*data CuadreCta2;*/
/*set CuadreCta1;*/
/*	Porcentaje_Diferencia = ((SaldoB29 - Saldo_ST)/Saldo_ST)*100;*/
/*	Diferencia = (SaldoB29 - Saldo_ST);*/
/*	Diferencia_abs = abs(SaldoB29 - Saldo_ST);*/
/*run;*/

/*end test CUADRE CONTABLE VS B29*/






/*PASO ADICIONAL 1*/
/*SE ANALIZA COMO ESTA EL MARGEN FINANCIERO ANTES DE APLICAR LA LOGICA DE
VER SI EL MARGEN TIENE UN DESCUADRE MAYOR AL 5% Y RELLENAR CON CONTRATOS FICTICIOS
EN DICHO CASO.
SE COMPARA VS EL MARGEN TOTAL (VIVAS + NO VIVAS)
*/

/*PASO ADICIONAL 1.1*/
/*SE ANALIZA EL SALDO Y MARGEN GLOBAL*/
PROC SQL;
	CREATE TABLE ANALISIS_PRELIMINAR_MARGEN AS
		SELECT a.INSTRUMENTO, a.SEGMENTO_FINREP, a.PROD_PRESTAMOS,
				a.PROD_DEPOSITOS, a.INDOPERVIVA,
				(case when a.INSTRUMENTO IN ("04","08") then C0068*b.Tipo_Cambio
				else a.C0016*b.Tipo_Cambio end) AS SALDO_SOLES,
				a.C0067*&Tipo_Cambio_Prom AS MARGEN_SOLES
			FROM SALIDA_FINAL_2017_CONTR_1_CUA1 a, 
				(select Tipo_Cambio from &bibliotecaInputs..Tipo_De_Cambio where Divisa="EUR") b;
QUIT;

/*PASO ADICIONAL 1.2*/
/*SE RESUME*/
PROC SQL;
	CREATE TABLE ANALISIS_PRELIMINAR_MARGEN2 AS
		SELECT INSTRUMENTO, SEGMENTO_FINREP, PROD_PRESTAMOS,
				PROD_DEPOSITOS, INDOPERVIVA,
				abs(SUM(SALDO_SOLES)) AS SALDO_SOLES,
				abs(SUM(MARGEN_SOLES)) AS MARGEN_SOLES
			FROM ANALISIS_PRELIMINAR_MARGEN
					GROUP BY 1,2,3,4,5;
QUIT;





/*PASO 4: AHORA SIGUE AGREGAR LOS CONTRATOS FICTICIOS DE SER NECESARIO
PARA PODER CUADRAR AL 100% VS F16 (MARGEN FINANCIERO)*/

/*PASO 4.1: SE NECESITA LOS MONTOS DE STRESS TEST AGRUPADOS 
POR SECTORES PARA PODER COMPARAR VS EL F16*/
PROC SQL;
	CREATE TABLE MARGEN_ST_SECTOR2 AS
		SELECT INSTRUMENTO, SEGMENTO_FINREP, ABS(SUM(C0067)) AS MARGEN
			FROM SALIDA_FINAL_2017_CONTR_1_CUA1
				WHERE(INSTRUMENTO IN ("02","05"))
					GROUP BY 1,2;
QUIT;

/*PASO 4.1.1: SE USAN NOMBRES MAS IDENTIFICABLES PARA EL SEGMENTO FINREP*/
proc sql;
	create table MARGEN_ST_SECTOR3 as
		select a.*, b.INSTRUMENTO_new as INSTRUMENTO2 format = $9.,
				b.SEGMENTO_FINREP_new as SEGMENTO_NUEVO format = $8.
			from MARGEN_ST_SECTOR2 a LEFT JOIN &biblioteca..H_Cuadre_F16 b
				ON a.INSTRUMENTO = b.INSTRUMENTO AND
					a.SEGMENTO_FINREP = b.SEGMENTO_FINREP;
quit;

/*PASO 4.1.2: AHORA EL FORMATO ES EL MISMO QUE EL DEL REPORTE F16*/
PROC SQL;
	CREATE TABLE MARGEN_ST_SECTOR4 AS
		SELECT INSTRUMENTO2, SEGMENTO_NUEVO, SUM(MARGEN) AS MARGEN
			FROM MARGEN_ST_SECTOR3
				GROUP BY 1,2;
QUIT;

/*PASO 4.1.3: YA SE PUEDE COMPARAR EN UNA SOLA TABLA ST VS F16*/
PROC SQL;
	CREATE TABLE MARGEN_ST_SECTOR5 AS
		SELECT A.INSTRUMENTO2 AS INSTRUMENTO, A.SEGMENTO_NUEVO AS SEGMENTO, A.MARGEN AS MARGEN_ST,
				B.MARGEN_EUR AS MARGEN_F16
					FROM MARGEN_ST_SECTOR4 A LEFT JOIN F16_REPORTE_EUR B
						ON A.INSTRUMENTO2 = B.INSTRUMENTO AND A.SEGMENTO_NUEVO = B.SECTOR;
QUIT;

/*PASO 4.1.4: AHORA SE CALCULA EL DESCUADRE Y UN MARCADOR QUE INDIQUE CUANDO
EL DESCUADRE ES ALTO*/
DATA MARGEN_ST_SECTOR6;
SET MARGEN_ST_SECTOR5;

	IF (MARGEN_ST = .) THEN
		DIFERENCIA = MARGEN_F16;
	ELSE
		DIFERENCIA = (MARGEN_F16 - MARGEN_ST);

	DIFERENCIA_PORC = (DIFERENCIA/MARGEN_ST)*100;
	
/*CUANDO EL DESCUADRE ES ALTO (>5%) UN MARCADOR INDICARA 
	QUE ES NECESARIO UNA CORRECCION*/
	IF (MARGEN_ST IN (0,.) OR DIFERENCIA_PORC > 5) THEN
		MARCADOR = 1;
	ELSE
		MARCADOR = 0;
RUN;

/*Se exporta en Euros y en Miles*/
DATA MARGEN_ST_SECTOR6_MIL;
SET MARGEN_ST_SECTOR6;
	MARGEN_ST = MARGEN_ST/1000;
	MARGEN_F16 = MARGEN_F16/1000;
	DIFERENCIA = DIFERENCIA/1000;
RUN;

proc sql;
	create table MARGEN_ST_SECTOR6_MIL2 as
		select a.INSTRUMENTO,
				b.SEGMENTO_FINREP_NEW as SEGMENTO_FINREP,
				a.Margen_ST, a.MARGEN_F16, a.DIFERENCIA, 
				a.DIFERENCIA_PORC, a.MARCADOR as MARCADOR_FICTICIO
			from MARGEN_ST_SECTOR6_MIL a LEFT JOIN &biblioteca..H_Cuadre_Margen_Descrip b
				ON a.INSTRUMENTO = b.INSTRUMENTO AND
					a.SEGMENTO = b.SEGMENTO_FINREP;
quit;

/*Se exporta el cuadre de Margen Financiero vs F16 previo al adicionamiento
de los contratos ficticios para tener una referencia*/
%exportXLS(MARGEN_ST_SECTOR6_MIL2, 
			&localProjectPath.&dirLog.&hora_generacion_pestana_ajust._Cuadre_Margen_Sin_Ficticios.xlsx,
			Euros_Mileados);


/*PASO 4.1.5: SE CREAN MACROVARIABLES PARA GUARDAR LOS DESCUADRES Y LOS MARCADORES*/
DATA _NULL_;
SET MARGEN_ST_SECTOR6;

	IF (INSTRUMENTO = "Credito" AND SEGMENTO = "BC_y_AP") THEN
		DO;
			CALL SYMPUT('MF_CR_BC_Y_AP', DIFERENCIA);
			CALL SYMPUT('IND_CR_BC_Y_AP', MARCADOR);
		END;
	ELSE IF (INSTRUMENTO = "Credito" AND SEGMENTO = "EC_y_OIF") THEN
		DO;
			CALL SYMPUT('MF_CR_EC_Y_OIF', DIFERENCIA);
			CALL SYMPUT('IND_CR_EC_Y_OIF', MARCADOR);
		END;
	ELSE IF (INSTRUMENTO = "Credito" AND SEGMENTO = "Parti") THEN
		DO;
			CALL SYMPUT('MF_CR_PARTI', DIFERENCIA);
			CALL SYMPUT('IND_CR_PARTI', MARCADOR);
		END;
	ELSE IF (INSTRUMENTO = "Credito" AND SEGMENTO = "SNF") THEN
		DO;
			CALL SYMPUT('MF_CR_SNF', DIFERENCIA);
			CALL SYMPUT('IND_CR_SNF', MARCADOR);
		END;
	ELSE IF (INSTRUMENTO = "Depositos" AND SEGMENTO = "AP") THEN
		DO;
			CALL SYMPUT('MF_DEP_AP', DIFERENCIA);
			CALL SYMPUT('IND_DEP_AP', MARCADOR);
		END;
	ELSE IF (INSTRUMENTO = "Depositos" AND SEGMENTO = "BC") THEN
		DO;
			CALL SYMPUT('MF_DEP_BC', DIFERENCIA);
			CALL SYMPUT('IND_DEP_BC', MARCADOR);
		END;
	ELSE IF (INSTRUMENTO = "Depositos" AND SEGMENTO = "EC_y_OIF") THEN
		DO;
			CALL SYMPUT('MF_DEP_EC_Y_OIF', DIFERENCIA);
			CALL SYMPUT('IND_DEP_EC_Y_OIF', MARCADOR);
		END;
	ELSE IF (INSTRUMENTO = "Depositos" AND SEGMENTO = "Parti") THEN
		DO;
			CALL SYMPUT('MF_DEP_PARTI', DIFERENCIA);
			CALL SYMPUT('IND_DEP_PARTI', MARCADOR);
		END;
	ELSE IF (INSTRUMENTO = "Depositos" AND SEGMENTO = "SNF") THEN
		DO;
			CALL SYMPUT('MF_DEP_SNF', DIFERENCIA);
			CALL SYMPUT('IND_DEP_SNF', MARCADOR);
		END;
RUN;

/*SE NECESITA DIVIDIR LOS MARGENES DE LOS SECTORES DE ACUERDO A 
LA REFERENCIA DE COMPARACION DE HOLDING*/

/*PASO 4.2: PRIMERO PARA PRESTAMOS*/
PROC SQL;
	CREATE TABLE MARGEN_SP_ST_SECTOR_CR AS
		SELECT INSTRUMENTO, SEGMENTO_FINREP, ABS(SUM(C0067)) AS MARGEN, SUM(C0016) AS SP
			FROM SALIDA_FINAL_2017_CONTR_1_CUA1
				WHERE(INSTRUMENTO IN ("02","05"))
					GROUP BY 1,2;
QUIT;

/*PASO 4.2.1: SNF SE DIVIDE EN PYMES Y RESTO, NECESITA UN TRATAMIENTO ESPECIAL*/
DATA MARGEN_SP_ST_SECTOR_CR2;
SET MARGEN_SP_ST_SECTOR_CR;
	WHERE(INSTRUMENTO = "02" AND SEGMENTO_FINREP IN ("004","005"));
RUN;

/*PASO 4.2.2: SE TRAE LA DIFERENCIA*/
PROC SQL;
	CREATE TABLE MARGEN_SP_ST_SECTOR_CR3 AS
		SELECT A.*, B.DIFERENCIA
			FROM MARGEN_SP_ST_SECTOR_CR2 A, 
				(SELECT DIFERENCIA FROM MARGEN_ST_SECTOR6
					WHERE (INSTRUMENTO = "Credito" AND SEGMENTO = "SNF")) B;
QUIT;

/*PASO 4.2.3: SE CALCULA EL SALDO PUNTUAL TOTAL*/
PROC SQL;
	CREATE TABLE MARGEN_SP_ST_SECTOR_CR4 AS
		SELECT A.*, SUM(SP) AS SUMA_SP 
			FROM MARGEN_SP_ST_SECTOR_CR3 A;
QUIT;

/*PASO 4.2.4: AHORA SE DISTRIBUYE EQUITATIVAMENTE LA DIFERENCIA EN BASE AL SALDO PUNTUAL*/
PROC SQL;
	CREATE TABLE MARGEN_SP_ST_SECTOR_CR5 AS
		SELECT A.*, (SP*DIFERENCIA)/SUMA_SP AS MARGEN_DIV
			FROM MARGEN_SP_ST_SECTOR_CR4 A;
QUIT;	

/*PASO 4.2.5: SE GUARDAN LOS RESULTADOS EN MACROVARIABLES*/
DATA _NULL_;
SET MARGEN_SP_ST_SECTOR_CR5;
	IF (SEGMENTO_FINREP = "004") THEN
		CALL SYMPUT('MF_CR_SNF_PYME', MARGEN_DIV);
	ELSE IF (SEGMENTO_FINREP = "005") THEN
		CALL SYMPUT('MF_CR_SNF_RESTO', MARGEN_DIV);
RUN;


/*PASO 4.2.6: EL SEGMENTO PARTICULARES ESTA DESGLOSADO EN LOS 3 PRODUCTOS PRESTAMOS*/
PROC SQL;
	CREATE TABLE MARGEN_SP_ST_SECTOR_CRE AS
		SELECT INSTRUMENTO, SEGMENTO_FINREP, PROD_PRESTAMOS, 
				ABS(SUM(C0067)) AS MARGEN, SUM(C0016) AS SP
				FROM SALIDA_FINAL_2017_CONTR_1_CUA1
					WHERE(INSTRUMENTO = "02" AND SEGMENTO_FINREP = "006")
						GROUP BY 1,2,3;
QUIT;

/*PASO 4.2.7: SE SELECCIONA LA DIFERENCIA*/
PROC SQL;
	CREATE TABLE CREDITO_DIFERENCIA AS
		SELECT SEGMENTO, DIFERENCIA
			FROM MARGEN_ST_SECTOR6
				WHERE(INSTRUMENTO = "Credito" AND SEGMENTO = "Parti");
QUIT;

/*PASO 4.2.8: SE RENOMBRA*/
DATA CREDITO_DIFERENCIA2;
SET CREDITO_DIFERENCIA;
	IF (SEGMENTO = "Parti") THEN
		SEGMENTO = "006";
RUN;

/*PASO 4.2.9: SE TRAE LA DIFERENCIA*/
PROC SQL;
	CREATE TABLE MARGEN_SP_ST_SECTOR_CRE2 AS
		SELECT A.*, B.DIFERENCIA
			FROM MARGEN_SP_ST_SECTOR_CRE A LEFT JOIN CREDITO_DIFERENCIA2 B
				ON A.SEGMENTO_FINREP = B.SEGMENTO;		
QUIT;

/*PASO 4.2.10: SE ORDENA*/
PROC SORT DATA=MARGEN_SP_ST_SECTOR_CRE2;
	BY SEGMENTO_FINREP PROD_PRESTAMOS;
RUN;

/*PASO 4.2.11: SE CALCULA EL SALDO PUNTUAL TOTAL*/
PROC SQL;
	CREATE TABLE MARGEN_SP_ST_SECTOR_CRE3 AS
		SELECT A.*, SUM(SP) AS SUMA_SP 
			FROM MARGEN_SP_ST_SECTOR_CRE2 A
				GROUP BY SEGMENTO_FINREP;
QUIT;

/*PASO 4.2.12: AHORA SE DISTRIBUYE EQUITATIVAMENTE LA DIFERENCIA EN BASE AL SALDO PUNTUAL*/
PROC SQL;
	CREATE TABLE MARGEN_SP_ST_SECTOR_CRE4 AS
		SELECT A.*, (SP*DIFERENCIA)/SUMA_SP AS MARGEN_DIV
			FROM MARGEN_SP_ST_SECTOR_CRE3 A;
QUIT;

/*PASO 4.2.13: EL SEGMENTO PARTICULARES DEBE ESTAR DISTRIBUIDO EN LOS 3 PRODUCTOS PRESTAMOS*/
DATA _NULL_;
SET MARGEN_SP_ST_SECTOR_CRE4;

	IF (SEGMENTO_FINREP = "006" AND PROD_PRESTAMOS = "01") THEN
		CALL SYMPUT('MF_CRE_PARTI_01', MARGEN_DIV);
	ELSE IF (SEGMENTO_FINREP = "006" AND PROD_PRESTAMOS = "02") THEN
		CALL SYMPUT('MF_CRE_PARTI_02', MARGEN_DIV);
	ELSE IF (SEGMENTO_FINREP = "006" AND PROD_PRESTAMOS = "03") THEN
		CALL SYMPUT('MF_CRE_PARTI_03', MARGEN_DIV);
RUN;


/*PASO 4.3: CON DEPOSITOS ES LA MISMA IDEA, 
SE DEBE REPARTIR EQUITATIVAMENTE EL MARGEN PARA CUADRAR VS F08*/

/*PASO 4.3.1: IGUALMENTE PARA DEPOSITOS, SE NECESITA REPARTIR EL SALDO EQUITATIVAMENTE*/
PROC SQL;
	CREATE TABLE MARGEN_SP_ST_SECTOR_DEP AS
		SELECT INSTRUMENTO, SEGMENTO_FINREP, PROD_DEPOSITOS, 
				ABS(SUM(C0067)) AS MARGEN, SUM(C0016) AS SP
				FROM SALIDA_FINAL_2017_CONTR_1_CUA1
					WHERE(INSTRUMENTO = "05")
						GROUP BY 1,2,3;
QUIT;

/*PASO 4.3.2: SE SELECCIONA LA DIFERENCIA*/
PROC SQL;
	CREATE TABLE DEPOSITOS_DIFERENCIA AS
		SELECT SEGMENTO, DIFERENCIA
			FROM MARGEN_ST_SECTOR6
				WHERE(INSTRUMENTO = "Depositos");
QUIT;

/*PASO 4.3.3: SE RENOMBRA*/
DATA DEPOSITOS_DIFERENCIA2;
SET DEPOSITOS_DIFERENCIA;
	IF(SEGMENTO = "AP") THEN
		SEGMENTO = "003";
	ELSE IF (SEGMENTO = "BC") THEN
		SEGMENTO = "001";
	ELSE IF (SEGMENTO = "EC_y_OIF") THEN
		SEGMENTO = "004";
	ELSE IF (SEGMENTO = "Parti") THEN
		SEGMENTO = "006";
	ELSE IF (SEGMENTO = "SNF") THEN
		SEGMENTO = "005";
RUN;

/*PASO 4.3.4: SE TRAE LA DIFERENCIA*/
PROC SQL;
	CREATE TABLE MARGEN_SP_ST_SECTOR_DEP2 AS
		SELECT A.*, B.DIFERENCIA
			FROM MARGEN_SP_ST_SECTOR_DEP A LEFT JOIN DEPOSITOS_DIFERENCIA2 B
				ON A.SEGMENTO_FINREP = B.SEGMENTO;		
QUIT;

/*PASO 4.3.5: SE ORDENA*/
PROC SORT DATA=MARGEN_SP_ST_SECTOR_DEP2;
	BY SEGMENTO_FINREP PROD_DEPOSITOS;
RUN;

/*PASO 4.3.6: SE CALCULA EL SALDO PUNTUAL TOTAL*/
PROC SQL;
	CREATE TABLE MARGEN_SP_ST_SECTOR_DEP3 AS
		SELECT A.*, SUM(SP) AS SUMA_SP 
			FROM MARGEN_SP_ST_SECTOR_DEP2 A
				GROUP BY SEGMENTO_FINREP;
QUIT;

/*PASO 4.3.7: AHORA SE DISTRIBUYE EQUITATIVAMENTE LA DIFERENCIA EN BASE AL SALDO PUNTUAL*/
PROC SQL;
	CREATE TABLE MARGEN_SP_ST_SECTOR_DEP4 AS
		SELECT A.*, (SP*DIFERENCIA)/SUMA_SP AS MARGEN_DIV
			FROM MARGEN_SP_ST_SECTOR_DEP3 A;
QUIT;	

/*PASO 4.3.8: SE GUARDAN LOS RESULTADOS EN MACROVARIABLES*/
DATA _NULL_;
SET MARGEN_SP_ST_SECTOR_DEP4;

	IF (SEGMENTO_FINREP = "003" AND PROD_DEPOSITOS = "010") THEN
		CALL SYMPUT('MF_DEP_AP_01', MARGEN_DIV);
	ELSE IF (SEGMENTO_FINREP = "003" AND PROD_DEPOSITOS = "020") THEN
		CALL SYMPUT('MF_DEP_AP_02', MARGEN_DIV);

	ELSE IF (SEGMENTO_FINREP = "004" AND PROD_DEPOSITOS = "010") THEN
		CALL SYMPUT('MF_DEP_EC_Y_OIF_01', MARGEN_DIV);
	ELSE IF (SEGMENTO_FINREP = "004" AND PROD_DEPOSITOS = "020") THEN
		CALL SYMPUT('MF_DEP_EC_Y_OIF_02', MARGEN_DIV);

	ELSE IF (SEGMENTO_FINREP = "005" AND PROD_DEPOSITOS = "010") THEN
		CALL SYMPUT('MF_DEP_SNF_01', MARGEN_DIV);
	ELSE IF (SEGMENTO_FINREP = "005" AND PROD_DEPOSITOS = "020") THEN
		CALL SYMPUT('MF_DEP_SNF_02', MARGEN_DIV);

	ELSE IF (SEGMENTO_FINREP = "006" AND PROD_DEPOSITOS = "010") THEN
		CALL SYMPUT('MF_DEP_PARTI_01', MARGEN_DIV);
	ELSE IF (SEGMENTO_FINREP = "006" AND PROD_DEPOSITOS = "020") THEN
		CALL SYMPUT('MF_DEP_PARTI_02', MARGEN_DIV);
RUN;


/*PASO 4.4: AHORA SE PROCEDE A INSERTAR LOS MONTOS AL TABLON DE ST*/

/*PASO 4.4.1: MACRO PARA INSERTAR UN CONTRATO FICTICIO CON EL MARGEN FALTANTE A NIVEL
SEGMENTO - PRODUCTO*/
%macro Insertar_Margen(contrato, margin, instru, seg_fin, prod_prest, prod_dep);

proc sql;
	insert into Salida_Final_2017_contr_1_Cua1
		set C0000="&contrato", 
			C0016 = 0,
			C0019 = "&fechaReporte",
			C0020 = "&sociedad_informante",
			C0021 = "Tercero",
			Marca_Intergrupo = 'TER',
			C0900 = "PE",
			C0901 = "PEN",
			C0022 = "PEN",
			c0041 = 0,
			C0067 = &margin,
			Instrumento = "&instru",
			Segmento_FINREP ="&seg_fin",
			Prod_Prestamos = "&prod_prest",
			Prod_Depositos = "&prod_dep",
			IndNewBus = "N",
			IndOperViva = "V",
			IndMatBus = "N";
quit;

%mend Insertar_Margen;


/*PASO 4.4.2: MACRO PARA INSERTAR TODOS LOS CONTRATOS FICTICIOS NECESARIOS PARA CUADRAR
EL MARGEN FINANCIERO VS EL F16*/
%macro CuadreMargen;

/*Credito*/	
	/*Bancos Centrales y Administraciones Publicas*/
	%if (&Ind_Cr_BC_y_AP = 1) %then
		%do;
			%Insertar_Margen(Cr_BC_y_AP,&MF_Cr_BC_y_AP,02,001,03,);
		%end;
	/*Entidades de Credito y Otras Instituciones Financieras*/
	%if (&Ind_Cr_EC_y_OIF = 1) %then
		%do;
			%Insertar_Margen(Cr_EC_y_OIF,&MF_Cr_EC_y_OIF,02,003,03,);		
		%end;
	/*Sociedades no Financieras*/
	%if (&Ind_Cr_SNF = 1) %then
		%do;
			%Insertar_Margen(Cr_SNF_Pyme,&MF_Cr_SNF_Pyme,02,004,03,);
			%Insertar_Margen(Cr_SNF_Resto,&MF_Cr_SNF_Resto,02,005,03,);
		%end;
	/*Particulares*/
	/*Segemento Particulares de Credito se divide en 3 por producto:
		01 -> Hipotecarios
		02 -> Consumo
		03 -> Resto*/
	%if (&Ind_Cr_Parti = 1) %then 
		%do;
			%Insertar_Margen(Cr_Parti_01,&MF_Cre_Parti_01,02,006,01,);
			%Insertar_Margen(Cr_Parti_02,&MF_Cre_Parti_02,02,006,02,);
			%Insertar_Margen(Cr_Parti_03,&MF_Cre_Parti_03,02,006,03,);
		%end;

/*Depositos*/
	/*Administraciones Publicas*/
	%if (&Ind_Dep_AP = 1) %then
		%do;
			%Insertar_Margen(Dep_AP_01,&MF_Dep_AP_01,05,003,,010);
			%Insertar_Margen(Dep_AP_02,&MF_Dep_AP_02,05,003,,020);			
		%end;
	/*Bancos Centrales*/
	%if (&Ind_Dep_BC = 1) %then
		%do;
			%Insertar_Margen(Dep_BC,&MF_Dep_BC,05,001,,010);			
		%end;
	/*Entidades de Credito y Otras Instituciones Financieras*/
	%if (&Ind_Dep_EC_y_OIF = 1) %then
		%do;
			%Insertar_Margen(Dep_EC_y_OIF_01,&MF_Dep_EC_y_OIF_01,05,004,,010);	
			%Insertar_Margen(Dep_EC_y_OIF_02,&MF_Dep_EC_y_OIF_02,05,004,,020);			
		%end;
	/*Sociedades no Financieras*/
	%if (&Ind_Dep_SNF = 1) %then
		%do;
			%Insertar_Margen(Dep_SNF_01,&MF_Dep_SNF_01,05,005,,010);	
			%Insertar_Margen(Dep_SNF_02,&MF_Dep_SNF_02,05,005,,020);			
		%end;
	/*Particulares*/
	%if (&Ind_Dep_Parti = 1) %then
		%do;

			%Insertar_Margen(Dep_Parti_01,&MF_Dep_Parti_01,05,006,,010);	
			%Insertar_Margen(Dep_Parti_02,&MF_Dep_Parti_02,05,006,,020);						
		%end;

%mend CuadreMargen;



/*SOLO EJECUTAR ESTA MACRO UNA VEZ, DE LO CONTRARIO SE AGREGARA
MAS VARIAS VECES LOS CONTRATOS FICTICIOS Y SE TENDRA MARGEN DE MAS*/
%CuadreMargen;

/*YA SE DEBE TENER CUADRARO EL MARGEN VS F16*/

/*PASO 5: SE HOMOLOGA EL VENCIMIENTO RESIDUAL*/
PROC SQL;
	CREATE TABLE SALIDA_FINAL_2017_CONTR_1_AGRUP2 AS 
		SELECT A.*,(CASE WHEN B.VALOR NE "" THEN B.VALOR ELSE "14" END) AS G027
			FROM
				SALIDA_FINAL_2017_CONTR_1_CUA1 A
			LEFT JOIN
				&BIBLIOTECA..H_TRAMOS_VENCIMIENTO B

				ON 
				A.C0050>=COTA_INFERIOR
				AND A.C0050<=COTA_SUPERIOR;
QUIT;

/*PASO 6: SE CARGA EL PLAN DE CUOTAS*/

/*EL PROBLEMA ES QUE HAY VARIOS CONTRATOS REPETIDOS, 
SOLO SE QUIERE PASAR UN PLAN DE CUOTAS POR CADA CONTRATO
ENTONCES SE CREA UN MARCADOR PARA SOLO HACER EL CRUCE EN EL PRIMER REPETIDO
*/

/*PASO 6.1: SE ORDENA POR CONTRATO*/
PROC SORT DATA=SALIDA_FINAL_2017_CONTR_1_AGRUP2;
	BY C0000;
RUN;

/*PASO 6.2: SE PONE UN MARCADOR PARA SOLO PASAR EL PLAN DE CUOTAS
1 VEZ POR CADA CONTRATO*/
DATA SALIDA_FINAL_2017_CONTR_1_AGRUP3;
SET SALIDA_FINAL_2017_CONTR_1_AGRUP2;
  COUNT + 1;
  BY C0000;
  IF FIRST.C0000 THEN COUNT = 1;
RUN;

/*PASO 6.3: SE CARGA LAS CUOTAS AL REPORTE DE STRESS TEST*/
PROC SQL;
CREATE TABLE SALIDA_FINAL_2017_CONTR_2 AS
	SELECT  A.*, B.Q2016_1_EUR, B.Q2016_2_EUR, B.Q2016_3_EUR, B.Q2016_4_EUR,  
			B.Q2017_1_EUR, B.Q2017_2_EUR, B.Q2017_3_EUR, B.Q2017_4_EUR,
			B.Q1_EUR AS C0053, B.Q2_EUR AS C0054, B.Q3_EUR  AS C0055, 
			B.Q4_EUR AS C0056, B.Q5_EUR AS C0057, B.Q6_EUR AS C0058, 
			B.Q7_EUR AS C0059, B.Q8_EUR AS C0060, B.Q9_EUR AS C0061, 
			B.Q10_EUR AS C0062, B.Q11_EUR AS C0063, B.Q12_EUR AS C0064, 
			B.Q13_EUR AS C0065
		FROM SALIDA_FINAL_2017_CONTR_1_AGRUP3 A LEFT JOIN &BIBLIOTECA..PLAN_CUOTAS2 B
			ON A.C0000 =  B.CONTRATO AND A.COUNT = 1;	
QUIT;

/*test*/

/*se filtran las que tienen al menos 1 cuota informada
601785*/
/*data test;*/
/*set SALIDA_FINAL_2017_CONTR_2;*/
/*	where(coalesce(C0053,C0054,C0055,C0056,C0057,C0058,C0059,C0060,*/
/*		C0061,C0062,C0063,C0064,C0065,0) ne 0);*/
/*run;*/

/*de las que tienen cuotas informadas, cuantas no tienen fecha de vencimiento*/
/*data test2;*/
/*set test;*/
/*	where(c0050 = .);*/
/*run;*/


/*end test*/


/*
PASO 7: SE HOMOLOGA LA FECHA DE ENTRADA EN MORA Y LA SITUACION DE DEFAULT DEL CONTRATO
FINI ES LA FECHA_ENTRADA_MORA
 C0034 ES LA SITUACION DE DEFAULT DEL CONTRATO
*/
PROC SQL;
	CREATE TABLE SALIDA_FINAL_2017_CONTR_3 AS
		SELECT A.*, B.FINI AS C0902, (CASE WHEN B.FINI NE . THEN 'S' ELSE 'N' END) AS C0034
			FROM SALIDA_FINAL_2017_CONTR_2 A LEFT JOIN MOROSOS2 B
				ON A.C0000 =  B.CONTRATO;
QUIT;


/*PASO 8: SE CALCULA EL PLAZO DE REFERENCIA Y OTROS CAMPOS NUEVOS*/
DATA SALIDA_FINAL_2017_CONTR_4;
SET SALIDA_FINAL_2017_CONTR_3;

	C0006=PROD_PRESTAMOS; 
	/*POR FINALIDAD FINREP(C0006):
	ESTE CAMPO SE USA PARA CALCULAR 'PRODUCTO PRÉSTAMOS' EXCLUSIVAMENTE, ENTONCES
	COMO YA TENEMOS INFORMADO 'PRODUCTO PRÉSTAMOS', SE PUEDE HACER EL PROCESO INVERSO*/

	IF (C0006 = "01") THEN
		C0006 = "V";
	ELSE IF (C0006 = "02") THEN
		C0006 = "C";
	ELSE IF (C0006 = "03") THEN
		C0006 = "R";

	C1011 = "C"; /*PARA 2015 Y 2016 QUE NO SE INFORMAN LAS CORRECCIONES DE VALOR IFRS9, 
	TODOS LOS REGISTROS TENDRAN "C" (CABECERA)*/

	C1050 = 0; /*PARA EJECUCIONES HASTA EL 2017 LAS CORRECCIONES DE VALOR IFRS9 ESTARAN EN 0 
				(VALOR POR DEFECTO)*/

	FORMAT FECHCOMPDAT2 DATE10.;
	FORMAT FECHPLAZREF DATE10.;

	FECHCOMPDAT = CAT(C0019,"31"); /*COMPLETAMOS LA FECHA DE DATOS*/
	FECHCOMPDAT2 = INPUT(FECHCOMPDAT,YYMMDD8.); /*FORMATO FECHA*/

	FECHPLAZREF = FECHCOMPDAT2 + PLAZOREF; /*LE AGREGAMOS LOS DIAS DEL PLAZO
	Y ESTA SERA COMO UNA FECHA DE VENCIMIENTO PARA CALCULAR EL CAMPO
	'PLAZO DE REFERENCIA' DEL REQUERIMIENTO AGREGADO */

RUN;

/*PASO 9: SE HOMOLOGA EL PLAZO DE REFERENCIA PARA OPERATIVAS VARIABLES*/
PROC SQL;
	CREATE TABLE SALIDA_FINAL_2017_CONTR_5 AS 
		SELECT A.*,B.VALOR AS TIPO_TRAMO_PLAZO_REF
			FROM
				SALIDA_FINAL_2017_CONTR_4 A
			LEFT JOIN
				&BIBLIOTECA..H_TRAMOS_VENCIMIENTO B

				ON 
				A.FECHPLAZREF>=COTA_INFERIOR
				AND A.FECHPLAZREF<=COTA_SUPERIOR;
QUIT;


/*PASO 10: SE CALCULA DE TIPO DE PRODUCTO FINREP*/
/*PASO 10.1: SE CALCULA PARA CREDITO*/
PROC SQL;
	CREATE TABLE SALIDA_FINAL_2017_CONTR_6 AS
		SELECT A.*, B.TIPO_PROD_FINREP FORMAT = $3.
			FROM SALIDA_FINAL_2017_CONTR_5 A LEFT JOIN
				&BIBLIOTECA..H_PRODUCTO_FINREP_CRE B
					ON A.CUENTA_NEOCON=B.CUENTA;
QUIT;

/*PASO 10.2: SE CALCULA PARA DEPOSITOS*/
PROC SQL;
	CREATE TABLE SALIDA_FINAL_2017_CONTR_7
(DROP= TIPO_PROD_FINREP RENAME = (TIPO_PROD_FINREP2 = TIPO_PROD_FINREP)) AS
		SELECT A.*, 
			CASE WHEN B.TIPO_PROD_FINREP NE "" THEN B.TIPO_PROD_FINREP
			   ELSE A.TIPO_PROD_FINREP END AS TIPO_PROD_FINREP2 FORMAT = $3.
			FROM SALIDA_FINAL_2017_CONTR_6 A LEFT JOIN
				&BIBLIOTECA..H_PRODUCTO_FINREP_DEP B
					ON A.CUENTA_NEOCON=B.CUENTA;
QUIT;

/*PASO 10.3: SE CALCULA PARA EMISIONES Y DERIVADOS*/
DATA SALIDA_FINAL_2017_CONTR_8(drop=TIPO_PROD_FINREP);
SET SALIDA_FINAL_2017_CONTR_7;
	IF (INSTRUMENTO = "06") THEN /*TODOS LAS EMISIONES SON EMPRESTITOS*/
		DO;
			TIPO_PROD_FINREP = "EMP";/*PAS-EMPRÉSTITOS*/
		END;

	/*ADEMAS PARA DERIVADOS, TENEMOS DA (ACTIVO) Y DP (PASIVO)*/
	IF (INSTRUMENTO = "04") THEN
		DO;
			TIPO_PROD_FINREP = "DA";
		END;
	ELSE IF (INSTRUMENTO = "08") THEN
		DO;
			TIPO_PROD_FINREP = "DP";
		END;

	C0002 = TIPO_PROD_FINREP; /*TIPO DE PRODUCTO FINREP*/

RUN;

/*PASO 11: SE HOMOLOGA EL INDICADOR DE DEPÓSITOS A LA VISTA TIPO CERO REGULADO*/

/*PROD_DEPOSITOS = "02" (A LA VISTA: CUENTA CORRIENTE Y CONTIAHORRO)*/
DATA SALIDA_FINAL_2017_CONTR_9;
SET SALIDA_FINAL_2017_CONTR_8;

FORMAT VECIMIENTO_CURVA DATE10.;
FORMAT APERTURA_CURVA DATE10.;
FORMAT C0039DIASEM DATE10.; /*VARIABLE TEMPORAL PARA CALCULAR APERTURA_CURVA*/

/*SOLO APLICA PARA DEPOSITOS A LA VISTA*/
	IF(INSTRUMENTO = "05" AND PROD_DEPOSITOS = "020") THEN
		DO;
			IF (C0026 = 0) THEN
				C1040 = "022"; /*DEPOSITOS A LA VISTA CON TASA 0 NO REGULADOS*/
			ELSE
				C1040 = "023"; /*OTROS*/
		END;
	ELSE
		C1040 = ""; /*VALOR POR DEFECTO PARA EL RESTO*/

/*ADEMAS A LOS CONTRATOS FICTICIOS QUE SON DE DEPOSITOS A LA VISTA LES DEBO PONER OTROS "023" */
	if (C0000 IN ("Dep_AP_02","Dep_EC_y_OIF_02","Dep_SNF_02","Dep_Parti_02")) THEN
		DO;
			C1040 = "023"; /*OTROS DEPOSITOS A LA VISTA*/
		END;


/*SE PREPARA LAS VARIABLES PARA EL CRUCE CON LA CURVA LIBRE DE RIESGO*/

	/*SE PUEDE ASUMIR UNA FECHA DE VENCIMIENTO PARA LAS TARJETAS,
		PARA LOS OTROS PRODUCTOS QUE NO TIENEN FECHA DE VENCIMIENTO ASUMIMOS 1 DIA DESPUES DEL
		CIERRE DE AÑO DE LA FECHA DE DATOS COMO FECHA VENCIMIENTO*/
		IF (SUBSTR(C0000,9,2) = "50") THEN
			DO;
				IF(C0022 = "PEN") THEN
					VECIMIENTO_CURVA = FECHCOMPDAT2 + 2.37*365; /*2.37 ANIOS*/
				ELSE
					VECIMIENTO_CURVA = FECHCOMPDAT2 + 2.57*365; /*2.57 ANIOS*/
			END;

		ELSE IF (C0050 = INPUT("31/12/9999",DDMMYY10.) OR C0050 = .) THEN
			VECIMIENTO_CURVA = FECHCOMPDAT2 + 1; /*31 DICIEMBRE + 1*/
		ELSE
			VECIMIENTO_CURVA = C0050;



	/*PARA EL CASO DE APERTURAS EN LOS FINES DE SEMANA, SE PUEDE ASUMIR EL VALOR DEL VIERNES*/
		IF(WEEKDAY(C0039) = 1) THEN /*DOMINGO = 1*/
			DO;
				C0039DIASEM = C0039 - 2;
			END;
		ELSE IF (WEEKDAY(C0039) = 7) THEN /*SABADO = 7*/
			DO;
				C0039DIASEM = C0039 - 1;
			END;
		ELSE 
			DO;
				C0039DIASEM = C0039; /*LUNES A VIERNES SI TENGO INFORMACION EN LA CURVA LIBRE*/
			END;

/*PARA LAS OPERACIONES CON FECHA DE APERTURA ANTERIOR A LO QUE OFRECE LA CURVA,
  SE TOMA LA MINIMA OFRECIDA POR LA CURVA*/
		IF (C0022 = "PEN") THEN
			DO;
				IF (C0039 < &APERTSOLES AND C0039 NE .) THEN /*SI FEC APERTURA ES ANTERIOR A LA MINIMA QUE OFRECE LA CURVA*/
					APERTURA_CURVA = &APERTSOLES; /*SOLES*/
				ELSE 
					APERTURA_CURVA = C0039DIASEM;
			END;
		ELSE 
			DO;
				IF (C0039 < &APERTDOLARES AND C0039 NE .) THEN 
					APERTURA_CURVA = &APERTDOLARES; /*DOLARES*/
				ELSE 
					APERTURA_CURVA = C0039DIASEM;
			END;
	
RUN;


/*PASO 12: SE HOMOLOGA LA CURVA LIBRE DE RIESGO*/

/*PASO 12.1: SE HOMOLOGA PARA DIVISA SOLES*/
/*PASO 12.1.1: SE ORDENA*/
PROC SORT DATA=&BIBLIOTECA..CURVA_LIBRE_SOL OUT=CURVA_SOLES;
	BY SOLES;
RUN;

/*PASO 12.1.2: SE TRANSPONE PARA TENER POR CADA FECHA DE APERTURA 
VARIAS FILAS DE FECHA DE VENCIMIENTO*/
PROC TRANSPOSE DATA=CURVA_SOLES OUT=CURVA_SOLES_TRANS;
	VAR '1'n '7'n '15'n '30'n '60'n '90'n '180'n '270'n '360'n '720'n '1080'n '1440'n '1800'n '2160'n '2520'n 
		'2880'n '3600'n '5400'n '7200'n '9000'n '10800'n;
	BY SOLES; 

RUN;

/*PASO 12.1.3: SE DA FORMATO*/
DATA CURVA_SOLES_TRANS2(KEEP=SOLES _NAME_2 COL1 RENAME=(_NAME_2 = DIAS_VENC COL1 = TASAREF));
SET CURVA_SOLES_TRANS;
	FORMAT _NAME_2 5.;
	_NAME_2 = INPUT(_NAME_,$5.);
RUN;

/*PASO 12.1.4: SE CREA LA VARIABLE DIAS_VENC2 PARA TRABAJAR POR RANGOS*/
/*PARA QUE NO SE AUMENTEN LOS REGISTROS AL HACER EL CRUZE YA QUE LOS DIAS_VENC NO SON MUY ESPECIFICOS
PARA LA FECHA DE VENCIMIENTO, MEJOR SE TENDRAN RANGOS DE FECHA DE VENCIMIENTO
EL RANGO PARA PREGUNTAR DONDE SE UBICA LA FECHA DE VENCIMIENTO SERA
DE DIAS_VENC2 A DIAS_VENC*/
DATA CURVA_SOLES_TRANS3 (DROP=DIAS_VENC_PREV SOLES_PREV);
SET CURVA_SOLES_TRANS2;
	DIAS_VENC_PREV = LAG(DIAS_VENC);
	SOLES_PREV = LAG(SOLES);

	IF (SOLES_PREV = SOLES) THEN
		DIAS_VENC2 = DIAS_VENC_PREV;
	ELSE /*EL RANGO INICIAL ES DE 0 A 1 DIA*/
		DIAS_VENC2 = 0;
RUN;	


/*PASO 12.1.5: AHORA SE CRUZA PO EL RANGO <DIAS_VENC2,DIAS_VENC]
Y SE SACA LA TASA DE LA CURVA LIBRE DE RIESGO*/
PROC SQL;
	CREATE TABLE SALIDA_FINAL_2017_CONTR_10 AS
		SELECT A.*, B.TASAREF AS TASA_LIBRE_SOLES
			FROM SALIDA_FINAL_2017_CONTR_9 A LEFT JOIN CURVA_SOLES_TRANS3 B
				ON (A.APERTURA_CURVA = B.SOLES) AND 
					(A.VECIMIENTO_CURVA - A.APERTURA_CURVA > B.DIAS_VENC2) AND (A.VECIMIENTO_CURVA - A.APERTURA_CURVA <= B.DIAS_VENC);
QUIT;

/*PASO 12.2: SE HOMOLOGA PARA DIVISA DOLARES*/
/*PASO 12.2.1: SE ORDENA*/
PROC SORT DATA=&BIBLIOTECA..CURVA_LIBRE_DOL OUT=CURVA_DOLARES;
	BY USD;
RUN;

/*PASO 12.2.2: SE TRANSPONE PARA TENER POR CADA FECHA DE APERTURA 
VARIAS FILAS DE FECHA DE VENCIMIENTO*/
PROC TRANSPOSE DATA=CURVA_DOLARES OUT=CURVA_DOLARES_TRANS;
	VAR '1'n '7'n '15'n '30'n '60'n '90'n '120'n '150'n '180'n '210'n '240'n '270'n 
		'300'n '330'n '360'n '720'n '1080'n '1800'n '2520'n '3600'n '10800'n;
	BY USD; 

RUN;

/*PASO 12.2.3: SE DA FORMATO*/
DATA CURVA_DOLARES_TRANS2(KEEP=USD _NAME_2 COL1 RENAME=(_NAME_2 = DIAS_VENC COL1 = TASAREF));
SET CURVA_DOLARES_TRANS;
	FORMAT _NAME_2 5.;
	_NAME_2 = INPUT(_NAME_,$5.);
RUN;

/*PASO 12.2.4: SE CREA LA VARIABLE DIAS_VENC2 PARA TRABAJAR POR RANGOS*/
DATA CURVA_DOLARES_TRANS3 (DROP=DIAS_VENC_PREV USD_PREV);
SET CURVA_DOLARES_TRANS2;
	DIAS_VENC_PREV = LAG(DIAS_VENC);
	USD_PREV = LAG(USD);

	IF (USD_PREV = USD) THEN
		DIAS_VENC2 = DIAS_VENC_PREV;
	ELSE /*EL RANGO INICIAL ES DE 0 A 1 DIA*/
		DIAS_VENC2 = 0;
RUN;	

/*PASO 12.2.5: AHORA SE CRUZA PO EL RANGO <DIAS_VENC2,DIAS_VENC]
Y SE SACA LA TASA DE LA CURVA LIBRE DE RIESGO*/
PROC SQL;
	CREATE TABLE SALIDA_FINAL_2017_CONTR_11 AS
		SELECT A.*, B.TASAREF AS TASA_LIBRE_DOLARES
			FROM SALIDA_FINAL_2017_CONTR_10 A LEFT JOIN CURVA_DOLARES_TRANS3 B
				ON (A.APERTURA_CURVA = B.USD) AND 
					(A.VECIMIENTO_CURVA - A.APERTURA_CURVA > B.DIAS_VENC2) AND (A.VECIMIENTO_CURVA - A.APERTURA_CURVA <= B.DIAS_VENC);
QUIT;

/*PASO 12.3: SE CONSOLIDA AMBAS DIVISAS: SOLES Y DOLARES*/
/*LA DEFINICION DICE QUE SI ES OPERATICA VARIABLE ENTONCES
C1009 Y C1008 TOMAN LOS VALORES QUE YA SE TENIAN DE TIPOREF Y SU CURVA,
PERO CUANDO ES OPERATIVA DE TIPO FIJA ENTONCES
AHI SI SE INFORMA LOS VALORES DE LA CURVA LIBRE DE RIESGO*/
DATA SALIDA_FINAL_2017_CONTR_12;
SET SALIDA_FINAL_2017_CONTR_11;

	IF (C0022 = "PEN") THEN
		DO;
			IF (C0023 = "F") THEN
				C1009 = TASA_LIBRE_SOLES; /*PARA OPERATIVAS FIJA SE USA LA CURVA LIBRE DE RIESGO*/
			ELSE IF (C0023 = "V") THEN
				C1009 = C0028; /*ES IGUAL AL 'VALOR APLICADO REFERENCIA' QUE YA SE TENIA COMO DATO*/
		END;
	ELSE 
		DO;
			IF (C0023 = "F") THEN
				C1009 = TASA_LIBRE_DOLARES;
			ELSE IF (C0023 = "V") THEN
				C1009 = C0028;
		END;


	C1008 = C0026 - C1009; /*SPREAD ASOCIADO A LA CURVA LIBRE DE RIESGO*/
		
RUN;

/*PASO 13: SE HOMOLOGA LA CARTERA CONTABLE*/

/*PASO 13.1: SE HOMOLOGA PARA DERIVADOS*/
DATA SALIDA_FINAL_2017_CONTR_13;
SET SALIDA_FINAL_2017_CONTR_12;
	FORMAT C0014 $2.;
	IF (INSTRUMENTO IN("04","08")) THEN
		DO;
			IF (PROD_DERIVADOS = "01") THEN 
				/*COBERTURA DE FLUJO DE CAJA*/
				C0014 = "9";
			ELSE IF (PROD_DERIVADOS = "02") THEN 
				/*COBERTURA DE VALOR RAZONABLE*/
				C0014 = "10";
			ELSE IF (PROD_DERIVADOS = "04") THEN
				/*DERIVADOS DE TRADING (NO USADO PARA CONTABILIDAD DE COBERTURAS)*/
				C0014 = "12";
		END;
RUN;

/*PASO 13.2: SE HOMOLOGA PARA CREDITOS Y DEPOSITOS*/
PROC SQL;
	CREATE TABLE SALIDA_FINAL_2017_CONTR_13_CR_DP
(DROP=C0014 RENAME = (C0014_NEW = C0014)) AS
		SELECT A.*, 
		CASE WHEN B.VALOR NE "" THEN B.VALOR ELSE A.C0014 END AS C0014_NEW FORMAT = $2.
			FROM SALIDA_FINAL_2017_CONTR_13 A LEFT JOIN 
				&BIBLIOTECA..H_CARTERA_CONTABLE B
				ON A.CUENTA_NEOCON = B.CUENTA;
QUIT;


/*PASO 14: SE CALCULA EL IMPORTE DE CUOTAS SIN VENCIMIENTO O REPRECIACIÓN*/
/*EN TEORIA HAY ALGUNOS CASOS DE TARJETA DE CREDITO QUE NO TIENEN FECHAS DE VENCIMIENTO
DE PAGO DE SUS CUOTAS, ESAS ENTRARIAN EN ESTE CAMPO*/
DATA SALIDA_FINAL_2017_CONTR_14;
SET SALIDA_FINAL_2017_CONTR_13_CR_DP;
	IF(C0050 = .) THEN /*FECHA VENCIMIENTO DESINFORMADA*/
		INDIC_FEC = 0;
	ELSE
		INDIC_FEC = 1;

	IF(COALESCE(Q2016_1_EUR, Q2016_2_EUR, Q2016_3_EUR, Q2016_4_EUR, 
				Q2017_1_EUR, Q2017_2_EUR, Q2017_3_EUR, Q2017_4_EUR, 
				C0053, C0054, C0055, C0056, C0057, C0058, 
				C0059, C0060, C0061, C0062, C0063, C0064, C0065, 0) = 0) THEN /*SI TODOS LOS IMPORTEN VACIOS*/
		INDIC_IMPORT = 0;
	ELSE
		INDIC_IMPORT = 1;
RUN;


/*PASO 15: SE PASAN LOS IMPORTES A MILES. ADEMAS EL REPORTE SOLO ACEPTA DIVISAS SOLES Y DOLARES*/
DATA SALIDA_FINAL_2017_CONTR_15;
SET SALIDA_FINAL_2017_CONTR_14;

/*C0068 (NOCIONAL), SALDO CONTABLE, SALDO MEDIO E INGRESOS/GASTOS ESTABAN EN UNIDADES,
	TODAS LAS CUOTAS DEL C0053 AL C0065 ESTABAN EN UNIDADES*/

	C0016 = C0016/1000; /*SALDO CONTABLE*/
	C0041 = C0041/1000; /*SALDO MEDIO*/
	C0067 = C0067/1000; /*INGRESOS/GASTOS*/
	C0068 = C0068/1000; /*NOCIONAL*/

	/*CUOTAS:*/

	Q2016_1_EUR = Q2016_1_EUR/1000;
	Q2016_2_EUR = Q2016_2_EUR/1000;
	Q2016_3_EUR = Q2016_3_EUR/1000;
	Q2016_4_EUR = Q2016_4_EUR/1000;

	Q2017_1_EUR = Q2017_1_EUR/1000;
	Q2017_2_EUR = Q2017_2_EUR/1000;
	Q2017_3_EUR = Q2017_3_EUR/1000;
	Q2017_4_EUR = Q2017_4_EUR/1000;

	C0053 = C0053/1000;
	C0054 = C0054/1000;
	C0055 = C0055/1000;
	C0056 = C0056/1000;
	C0057 = C0057/1000;
	C0058 = C0058/1000;
	C0059 = C0059/1000;
	C0060 = C0060/1000;
	C0061 = C0061/1000;
	C0062 = C0062/1000;
	C0063 = C0063/1000;
	C0064 = C0064/1000;
	C0065 = C0065/1000;

	IF ((INDIC_FEC = 0) AND (INDIC_IMPORT = 0)) THEN
		C0066 = ABS(C0016);/*'IMPORTE DE CUOTAS SIN VENCIMIENTO O REPRECIACION ES IGUAL AL SALDO CONTABLE*/

/*REQUERIMIENTO HOLDING: LA DIVISA SOLO PUEDE SER PEN O USD EN SU DEFECTO*/
	IF (C0022 NE "PEN") THEN
		C0022 = "USD";
RUN;


/*PASO 16: SE COMPLETA EL CAMPO INDICE DE REFERENCIA Y SE TRATA LAS CUOTAS DE LOS DEPOSITOS A LA VISTA*/
DATA SALIDA_FINAL_2017_CONTR_16;
SET SALIDA_FINAL_2017_CONTR_15;
	IF(C0023 = "F") THEN /*TAMBIEN SE REQUIERE INFORMAR EL INDICE DE REFERENCIA PARA LAS OPERATIVAS FIJAS*/
		DO;
			IF(C0022 = "PEN") THEN
				DO;
					C0027 = "304"; /*INDICE DE REFERENCIA: BONOS SOBERANOS*/
				END;
			ELSE IF(C0022 = "USD") THEN
				DO;
					C0027 = "303"; /*INDICE DE REFERENCIA: TREASURIES*/
				END;
		END;
	
	/*PARA LOS DEPOSITOS A LA VISTA, LA PRIMERA CUOTA DEBE CUBRIR EL 100%
		DE LA AMORTIZACION*/
		IF (INSTRUMENTO = "05" AND PROD_DEPOSITOS = "020" AND INDOPERVIVA = "V") THEN
			DO;
				IF(&FECHAREPORTE = 201512) THEN
					DO;
						Q2016_1_EUR = ABS(C0016);
					END;
				ELSE IF(&FECHAREPORTE = 201612) THEN
					DO;
						Q2017_1_EUR = ABS(C0016);
					END;
				ELSE IF(&FECHAREPORTE = 201712) THEN
					DO;
						C0053 = ABS(C0016);
					END;
			END;
RUN;

/*PASO 17: SE CREAN MARCAS PARA SEPARAR LOS CASOS QUE NO INFORMAN SALDO CONTABLE, SALDO MEDIO
Y/O MARGEN FINANCIERO*/
DATA SALIDA_FINAL_2017_CONTR_16_MARC;
SET SALIDA_FINAL_2017_CONTR_16;

	IF C0041=. THEN
		MARCASM='N';
	ELSE MARCASM='S';

	IF C0016=. THEN
		MARCASC='N';
	ELSE MARCASC='S';

	IF C0067=. THEN
		MARCAGASTOS='N';
	ELSE MARCAGASTOS='S';

RUN;


/*PASO 18: SE RESUME LA SALIDA FINAL DE STRESS TEST A NIVEL CONTRATO*/
/*(EXTENDOBSCOUNTER=NO) PARA SOLUCIONAR EL PROBLEMA DE VERSIONES DE SAS*/
/*TASAS EN PORCENTAJE
SALDOS MILEADOS Y EN EUROS*/
PROC SQL;
	CREATE TABLE SALIDA_FINAL_2017_CONTR_17 AS
		SELECT  C0000, C0001, C0002, C0005, C0006, C0014, ABS(SUM(C0016)) AS C0016, C0019, C0020, C0021, C0022, C0023, 
				C0024, C0025, 

				(SUM(C0026*abs(C0016))/SUM(abs(C0016))) AS C0026_SP,
				(SUM(C0026*abs(C0068))/SUM(abs(C0068))) AS C0026_NOC,
				(SUM(C0026)/COUNT(C0026)) AS C0026_NOVIV,

				C0027, 
				(SUM(C0028*ABS(C0016))/SUM(ABS(C0016))) AS C0028, 
				(SUM(C0029*ABS(C0016))/SUM(ABS(C0016))) AS C0029, C0030, C0034, MAX(C0038) AS C0038 FORMAT = DATE10., 
				MIN(C0039) AS C0039 FORMAT = DATE10., MAX(C0040) AS C0040 FORMAT = DATE10.,
				ABS(SUM(C0041)) AS C0041, MAX(C0050) AS C0050 FORMAT = DATE10., C0052, 
				SUM(Q2016_1_EUR) AS Q2016_1_EUR, SUM(Q2016_2_EUR) AS Q2016_2_EUR,
				SUM(Q2016_3_EUR) AS Q2016_3_EUR, SUM(Q2016_4_EUR) AS Q2016_4_EUR,
				SUM(Q2017_1_EUR) AS Q2017_1_EUR, SUM(Q2017_2_EUR) AS Q2017_2_EUR, 
				SUM(Q2017_3_EUR) AS Q2017_3_EUR, SUM(Q2017_4_EUR) AS Q2017_4_EUR, 
				SUM(C0053) AS C0053, 
				SUM(C0054) AS C0054, SUM(C0055) AS C0055, SUM(C0056) AS C0056, SUM(C0057) AS C0057, 
				SUM(C0058) AS C0058, SUM(C0059) AS C0059, SUM(C0060) AS C0060, SUM(C0061) AS C0061, 
				SUM(C0062) AS C0062, SUM(C0063) AS C0063, SUM(C0064) AS C0064, SUM(C0065) AS C0065, 
				SUM(C0066) AS C0066, ABS(SUM(C0067)) AS C0067, ABS(SUM(C0068)) AS C0068, 
				C0900, C0901, C0902, C0973, (SUM(C1008*ABS(C0016))/SUM(ABS(C0016))) AS C1008,
				(SUM(C1009*ABS(C0016))/SUM(ABS(C0016))) AS C1009, C1010, C1011, C1014, C1040, SUM(C1050) AS C1050
				
			FROM SALIDA_FINAL_2017_CONTR_16_MARC
			GROUP BY C0000, C0001, C0002, C0005, C0006, C0014, C0019, C0020, C0021, C0022, C0023, 
				C0024, C0025, C0027, C0030, C0034, C0040, C0052, C0900, C0901, C0902, C0973,
				C1010, C1011, C1014, C1040,MARCASM,MARCASC,MARCAGASTOS;	
QUIT;


/*Tipo de Interes*/
DATA &BIBLIOTECAOUTPUTS..SALIDA_FINAL_STRESS_&FECHAREPORTE(drop=C0026_NOVIV C0026_NOC C0026_SP EXTENDOBSCOUNTER=NO);
SET SALIDA_FINAL_2017_CONTR_17;
	IF (C0016 IN (0,.) AND C0068 IN (0,.)) then /*Operativas no Vivas*/
		C0026 = C0026_NOVIV;
	ELSE IF (C0016 IN (0,.) AND C0068 NOT IN (0,.)) then /*Derivados con Nocional*/
		C0026 = C0026_NOC;
	ELSE /*Resto se pondera con saldo puntual*/
		C0026 = C0026_SP;
RUN;





/*%borrarTabla(Salida_Final_2017_contr_17);*/
/*%borrarTabla(Salida_Final_2017_contr_16);*/
/*%borrarTabla(Salida_Final_2017_contr_15);*/
/*%borrarTabla(Salida_Final_2017_contr_14);*/
/*%borrarTabla(Salida_Final_2017_contr_13);*/
/*%borrarTabla(Salida_Final_2017_contr_12);*/
/*%borrarTabla(Salida_Final_2017_contr_11);*/
/*%borrarTabla(Salida_Final_2017_contr_10);*/
/*%borrarTabla(Salida_Final_2017_contr_9);*/
/*%borrarTabla(Salida_Final_2017_contr_8);*/
/*%borrarTabla(Salida_Final_2017_contr_7);*/
/*%borrarTabla(Salida_Final_2017_contr_6);*/
/*%borrarTabla(Salida_Final_2017_contr_5);*/
/*%borrarTabla(Salida_Final_2017_contr_4);*/
/*%borrarTabla(Salida_Final_2017_contr_3);*/



/**********************AHORA SE GENERA EL TABLON DE REQUERIMIENTO AGREGADO***********************/




/*test*/

/*proc sql;*/
/*	create table test as*/
/*		select DIAS, substr(C0000,9,2) as producto, C0039 as fecha_contrat,*/
/*					year(C0039) as anio_apert,C0050 as fecha_vcto, */
/*					C0000 as contrato, C0016 as saldo_cont, C0067 as margen,*/
/*					C0068 as Nocional, CTA_CONTABLE, Cuenta_NEOCON, INSTRUMENTO,*/
/*					SEGMENTO_FINREP, PROD_PRESTAMOS, PROD_DEPOSITOS, INDOPERVIVA*/
/*			from SALIDA_FINAL_2017_CONTR_16*/
/*				where (instrumento = "02" and SEGMENTO_FINREP = "006" and PROD_PRESTAMOS = "01")*/
/*					order by DIAS desc;*/
/*quit;*/
/**/
/*proc sql;*/
/*	create table test_2 as*/
/*		select anio_apert, producto, sum(saldo_cont) as saldo_cont, count(*) as cuenta*/
/*			from test*/
/*				group by 1,2;*/
/*quit;*/
/**/
/*data test_muestra;*/
/*set test(firstobs=1 obs=5000);*/
/*run;*/

/*end test*/



/*PASO 19: SE GENERA VARIABLE AUXX2 PARA EL CALCULO DEL VENCIMIENTO ORIGINAL PROMEDIO*/
DATA AGREGADO_PREVIO;
SET SALIDA_FINAL_2017_CONTR_16;

/*DIAS SON LOS DIAS ENTRE FECHA DE APERTURA Y FECHA VENCIMIENTO*/
	IF (INSTRUMENTO IN ("04","08")) THEN
		DO;	
			AUXX2 = DIAS * abs(C0068); /*PARA DERIVADOS SE USA EL NOCIONAL*/
		END;
	ELSE 
		DO;
			AUXX2 = DIAS * abs(C0016); /*PARA LOS DEMAS SE USA EL SALDO CONTABLE*/
		END;
	

	IF C0041=. THEN
		MARCASM='N';
	ELSE MARCASM='S';

	IF C0016=. THEN
		MARCASC='N';
	ELSE MARCASC='S';

	IF C0067=. THEN
		MARCAGASTOS='N';
	ELSE MARCAGASTOS='S';
RUN;

/*PASO 20: EN EL REQUERIMIENTO AGREGADO, EXIGEN AL VALOR SPREAD ASOCIADO 
A LA CURVA LIBRE DE RIESGO TRAMEADO: C1008 TRAMEADO*/
PROC SQL;
	CREATE TABLE AGREGADO1 AS 
		SELECT 
			A.*,
		
		 B.TIPO_TRAMO AS SPREAD_CURVA_R

		FROM
			AGREGADO_PREVIO A
		LEFT JOIN
			&BIBLIOTECA..H_TRAMOS_TIPO B
			ON
			A.C1008>B.COTA_INFERIOR  /*C1008: VALOR SPREAD ASOCIADO A LA CURVA LIBRE DE RIESGO*/
			AND 
			A.C1008<=B.COTA_SUPERIOR
;
QUIT;

/*PASO 21: TAMBIEN EXIGEN LA TASA DE REFERENCIA DE LA CURVA LIBRE DE RIESGO EN TRAMOS*/
PROC SQL;
	CREATE TABLE AGREGADO2 AS 
		SELECT 
			A.*,
		
		 B.TIPO_TRAMO AS TIPREF_CURVA_R

		FROM
			AGREGADO1 A
		LEFT JOIN
			&BIBLIOTECA..H_TRAMOS_TIPO B
			ON
			A.C1009>B.COTA_INFERIOR  /*C1009: TIPO DE INTERÉS ASOCIADO A LA CURVA LIBRE DE RIESGO*/
			AND 
			A.C1009<=B.COTA_SUPERIOR
;
QUIT;

/*PASO 22: SE HOMOLOGA EL PLAZO DE REFERENCIA
EL REQUERIMIENTO EXIGE QUE SE INFORME EL PLAZO DE REFERENCIA TMB PARA LAS OPERTIVAS FIJAS*/
/*PASO 22.1: SE CALCULA EL PLAZO DE REFERENCIA PARA LOS PRODUCTOS CUENTA CORRIENTE,
CUENTA AHORROS, CTS Y TARJETAS DE OPERATIVAS FIJAS*/
DATA AGREGADO3;
SET AGREGADO2;	

	FORMAT FECDAT2 DATE10.;
	FORMAT FECPLAZO DATE10.;

	PRODUCTO = SUBSTR(C0000,9,2);
	FECDAT = CAT(C0019,"31"); /*COMPLETAMOS LA FECHA DE DATOS*/
	FECDAT2 = INPUT(FECDAT,YYMMDD8.); /*FORMATO FECHA*/


	/*SE DEFINE CON LA FECHA DE VENCIMIENTO PARA LOS PRODUCTOS QUE LA TENGAN,
	CASO CONTRARIO SE USA LA PARAMETRIA QUE NOS PASO WILLIAM DE GESTION FINANCIERA*/
	 IF (PRODUCTO IN ("01","02")) THEN
		DO;
			FECPLAZO = FECDAT2 + 1460; /*4 ANIOS PARA DEPOSITOS*/
		END;
	ELSE IF (PRODUCTO = "07") THEN
		DO;
			FECPLAZO = FECDAT2 + 2555; /*7 ANIOS PARA CTS*/
		END;	
	ELSE IF  (PRODUCTO = "50") THEN
		DO;
			FECPLAZO = FECDAT2 + 60; /*60 DIAS PARA TARJETAS*/
		END;
RUN;

/*PASO 22.2: SE HOMOLOGA LO CALCULADO EN EL PASO ANTERIOR*/
PROC SQL;
	CREATE TABLE AGREGADO4 AS 
		SELECT A.*,B.VALOR AS TRAMO_PLAZO_REF
			FROM
				AGREGADO3 A
			LEFT JOIN
				&BIBLIOTECA..H_TRAMOS_VENCIMIENTO B

				ON 
				A.FECPLAZO>=COTA_INFERIOR
				AND A.FECPLAZO<=COTA_SUPERIOR;
QUIT;

/*PASO 22.3: SE CALCULA EL PLAZO DE REFERENCIA PARA LOS DEMAS PRODUCTOS DE OPERATIVA FIJA.
SE DEFINE IGUAL A LA FECHA DE VENCIMIENTO*/
DATA AGREGADO5;
SET AGREGADO4;
/*SI ES UNO DE LOS PRODUCTOS DE LA PARAMETRÍA POR DEFECTO ENTONCES TOMA EL VALOR POR DEFECTO*/
	IF(PRODUCTO IN ("01", "02", "07", "50")) THEN
		PLAZO_R = TRAMO_PLAZO_REF;
	ELSE 
	/*SINO EL PLAZO DE REFERENCIA SE CALCULA CON LA FECHA DE VENCIMIENTO (G027)*/
		DO;
			IF (G027 NE "") THEN
				PLAZO_R = G027;
			ELSE /*EN CASO QUE G027 NO ESTE INFORMADA SE PONE VALOR POR DEFECTO 01 (2018Q1)*/
				PLAZO_R = "01";
		END;
		
RUN;

/*PASO 22.4: SE CONSOLIDA LO CALCULADO PARA OPERATIVA FIJA Y VARIABLE*/
DATA AGREGADO6;
SET AGREGADO5;
	IF(C0023="V") THEN /*SI ES OPERATIVA VARIABLE YA TIENE SU VALOR DE PLAZO DE REFERENCIA CALCULADO*/
		PLAZO_DE_REFERENC= TIPO_TRAMO_PLAZO_REF;	
	ELSE IF (C0023="F") THEN /*SI ES OPERATIVA FIJA SE TOMA EL VALOR CALCULADO EN ESTE PASO*/
		PLAZO_DE_REFERENC= PLAZO_R;
RUN;







/*test*/
/*proc sql;*/
/*	create table test as*/
/*		select */
/*					SALDO_PUNTUAL , SALDO_MEDIO, ING_GAST,*/
/*					SUM_NOCIONAL, INSTRUMENTO,*/
/*					SEGMENTO_FINREP, PROD_PRESTAMOS, PROD_DEPOSITOS, INDOPERVIVA,*/
/*					VTO_ORI_PROM_SP, VTO_ORI_PROM_NOC*/
/*			from REQUERIMIENTO_AGREGADO_PREVIO*/
/*				order by VTO_ORI_PROM_SP desc;*/
/*quit;*/
/**/
/*data test_muestra;*/
/*set test(firstobs=1 obs=2000);*/
/*run;*/
/**/
/**/
/*data test_vop;*/
/*set AGREGADO6;*/
/*	where(INDOPERVIVA = "V" AND INSTRUMENTO = "05" AND SEGMENTO_FINREP IN ("004")*/
/*			);*/
/*run;*/
/**/
/*proc sql;*/
/*	create table test_vop2 as*/
/*		select */
/*				DIAS, substr(C0000,9,2) as producto, C0039 as fecha_contrat,*/
/*				year(C0039) as anio_apert,C0050 as fecha_vcto, */
/*				C0000 as contrato, C0016 as saldo_cont, C0067 as margen,*/
/*				C0068 as Nocional, CTA_CONTABLE, Cuenta_NEOCON, INSTRUMENTO,*/
/*				SEGMENTO_FINREP, PROD_PRESTAMOS, PROD_DEPOSITOS*/
/*			from test_vop*/
/*				order by dias desc;*/
/*quit;*/


/*end test*/



/*Calculo de tipoTae ponderado, necesario para validaciones
tipo implicito vs tipo informado*/
data AGREGADO7;
set AGREGADO6;
	Tipo_Tae_SP = C0026 * abs(C0016);
	Tipo_Tae_SM = C0026 * abs(C0041);
run;


/*test*/

/*data test(keep=INSTRUMENTO SEGMENTO_FINREP C0000 CTA_CONTABLE INDOPERVIVA */
/*			C0068 c0026 C0016 C0041 C0067 tipo_Implicito diferencia dif_Porc);*/
/*set AGREGADO7;*/
/*	C0016 = abs(C0016);*/
/*	C0041 = abs(C0041);*/
/*	C0067 = abs(C0067);*/
/*	tipo_Implicito = (C0067/C0041)*100;*/
/**/
/*	diferencia = c0026 - tipo_Implicito;*/
/*	dif_Porc = ((c0026 - tipo_Implicito)/tipo_Implicito)*100;*/
/**/
/*	diferencia = C0041 - C0016;*/
/*	dif_Porc = ((C0041 - C0016)/C0016)*100;*/
/*run;*/
/**/
/*proc sql;*/
/*	create table test2 as*/
/*		select **/
/*			from test*/
/*				where(INDOPERVIVA = "F")*/
/*					order by diferencia desc;*/
/*quit;*/
/**/
/*data test3;*/
/*set test2(firstobs=1 obs=10000);*/
/*run;*/
/**/
/**/
/*data anali_tipo_imp (where=(dif_Porc>50));*/
/*set test2;*/
/*	prod = substr(C0000,9,2);*/
/*	mayor = cat(substr(CTA_CONTABLE,1,2),"0",substr(CTA_CONTABLE,4,1));*/
/*run;*/
/**/
/*proc freq data=anali_tipo_imp;*/
/*	tables mayor;*/
/*run;*/
/**/
/**/
/*data anali_SM;*/
/*set test;*/
/*	where(C0041 > C0016 AND C0016 ne .);*/
/*run;*/

/*end test*/




/*PASO 23: SE AGRUPA Y RESUME LA SALIDA FINAL A NIVEL AGREGADO*/
PROC SQL;
	CREATE TABLE REQUERIMIENTO_AGREGADO_PREVIO AS
		SELECT C0019 AS FECHA_DATOS, C0020 AS ENTIDAD, MARCA_INTERGRUPO AS MARCA_INTER, 
			   INSTRUMENTO, PROD_PRESTAMOS, PROD_DERIVADOS, PROD_DEPOSITOS, PROD_EMIRF, 
			   SEGMENTO_FINREP, C0900 AS PAIS, C0022 AS DIVISA_OP, C1040 AS TIPO_DEP_VISTA ,
			   C0023 AS TIPO_FV, C0027 AS INDICEREF,PLAZO_DE_REFERENC AS  PLAZ_REF, TIPREF_CURVA_R AS VALREF,
			   SPREAD_CURVA_R AS VALOR_SPREAD, INDNEWBUS, INDMATBUS, INDOPERVIVA, 
			   C0034 AS NON_PERFORM, 
			   ROUND(SUM(AUXX2)/SUM(abs(C0016))/365) AS VTO_ORI_PROM_SP, 
			   ROUND(SUM(AUXX2)/SUM(abs(C0068))/365) AS VTO_ORI_PROM_NOC, 

			   sum(Tipo_Tae_SP)/sum(abs(C0016)) as EIR_SP,
			   sum(Tipo_Tae_SM)/sum(abs(C0041)) as EIR_SM,		

			   G027 AS VTO_RESID, C0030 AS PLAZO_REPREC, 
			   ABS(SUM(C0016)) AS SALDO_PUNTUAL,  
			   ABS(SUM(C0068)) AS SUM_NOCIONAL,
			   ABS(SUM(C0041)) AS SALDO_MEDIO, SUM(C1050) AS PROVISIONES, ABS(SUM(C0067)) AS ING_GAST, 
			   SUM(Q2016_1_EUR) AS Q2016_1_EUR, SUM(Q2016_2_EUR) AS Q2016_2_EUR,
			   SUM(Q2016_3_EUR) AS Q2016_3_EUR, SUM(Q2016_4_EUR) AS Q2016_4_EUR,
			   SUM(Q2017_1_EUR) AS Q2017_1_EUR, SUM(Q2017_2_EUR) AS Q2017_2_EUR, 
		       SUM(Q2017_3_EUR) AS Q2017_3_EUR, SUM(Q2017_4_EUR) AS Q2017_4_EUR,

			   SUM(C0053) AS Q1_2018, SUM(C0054) AS Q2_2018, SUM(C0055) AS Q3_2018,SUM(C0056) AS Q4_2018,
			   SUM(C0057) AS Q1_2019, SUM(C0058) AS Q2_2019, SUM(C0059) AS Q3_2019,SUM(C0060) AS Q4_2019,
			   SUM(C0061) AS Q1_2020, SUM(C0062) AS Q2_2020, SUM(C0063) AS Q3_2020,SUM(C0064) AS Q4_2020,
			   SUM(C0065) AS Q2020PP

			   FROM AGREGADO7
			   		GROUP BY FECHA_DATOS, ENTIDAD, MARCA_INTER, INSTRUMENTO, PROD_PRESTAMOS, PROD_DERIVADOS,
							PROD_DEPOSITOS, PROD_EMIRF, SEGMENTO_FINREP, PAIS, DIVISA_OP, TIPO_DEP_VISTA, 
							TIPO_FV, INDICEREF, PLAZ_REF,VALREF, VALOR_SPREAD, INDNEWBUS, INDMATBUS, INDOPERVIVA, 
							NON_PERFORM, VTO_RESID, PLAZO_REPREC, MARCASC, MARCASM, MARCAGASTOS;


QUIT;

/*%borrarTabla(Agregado6);*/
/*%borrarTabla(Agregado5);*/
/*%borrarTabla(Agregado4);*/
/*%borrarTabla(Agregado3);*/
/*%borrarTabla(Agregado2);*/
/*%borrarTabla(Agregado1);*/
/*%borrarTabla(Agregado_previo);*/

/*PASO 24: PARA LOS CAMPOS SALDO CONTABLE Y VENCIMIENTO ORIGINAL PROMEDIO,
SE CONSOLIDA LA INFORMACION DE DERIVADOS CON EL RESTO DE PRODUCTOS*/
DATA REQUERIMIENTO_AGREGADO_PREVIO_2
(DROP=SALDO_PUNTUAL SUM_NOCIONAL VTO_ORI_PROM_NOC VTO_ORI_PROM_SP);
SET REQUERIMIENTO_AGREGADO_PREVIO;	
	format Indicador_EIR $2.;

	IF (INSTRUMENTO IN ("04","08")) THEN /*PARA DERIVADOS SE INFORMA EL NOCIONAL*/
		DO;
			SALDO_CONTABLE = SUM_NOCIONAL;
			VTO_ORI_PROM = VTO_ORI_PROM_NOC;
		END;
		
	ELSE
		DO;
			SALDO_CONTABLE = SALDO_PUNTUAL;
			VTO_ORI_PROM = VTO_ORI_PROM_SP;
		END;
		

	IF (VTO_ORI_PROM = .) THEN
		VTO_ORI_PROM = 0;

		/*REQUERIMIENTO HOLDING: VOP = 0 PARA TODOS LOS DEPOSITOS A LA VISTA*/
	IF (INSTRUMENTO = "05" AND PROD_DEPOSITOS = "020") THEN
		VTO_ORI_PROM = 0;


	/*Para el tipo de interes ponderado*/
	IF (SALDO_MEDIO NOT IN (0,.)) THEN
		DO;
			EIR_Informado = EIR_SM;
			Indicador_EIR = "SM";
		END;
	ELSE
		DO;
			EIR_Informado = EIR_SP;
			Indicador_EIR = "SP";
		END;
RUN;


/*PASO 25: SE GENERA LA TABLA DE SALIDA FINAL STRESS TEST PARA EL REQUERIMIENTO AGREGADO*/
PROC SQL;
	CREATE TABLE &BIBLIOTECAOUTPUTS..REQUERIMIENTO_AGREGADO_&FECHAREPORTE (EXTENDOBSCOUNTER=NO) AS
		SELECT FECHA_DATOS, ENTIDAD, MARCA_INTER, INSTRUMENTO, PROD_PRESTAMOS, PROD_DERIVADOS, 
				PROD_DEPOSITOS, PROD_EMIRF, SEGMENTO_FINREP, PAIS, DIVISA_OP, TIPO_DEP_VISTA,
				TIPO_FV, INDICEREF, PLAZ_REF, VALREF, VALOR_SPREAD, EIR_Informado, Indicador_EIR,
				INDNEWBUS, INDMATBUS, INDOPERVIVA,
				NON_PERFORM, VTO_ORI_PROM, VTO_RESID, PLAZO_REPREC, SALDO_CONTABLE, SALDO_MEDIO,
				PROVISIONES, ING_GAST, Q2016_1_EUR, Q2016_2_EUR, Q2016_3_EUR, Q2016_4_EUR, 
				Q2017_1_EUR, Q2017_2_EUR, Q2017_3_EUR, Q2017_4_EUR, 
				Q1_2018, Q2_2018, Q3_2018, Q4_2018, Q1_2019, Q2_2019, Q3_2019,
				Q4_2019, Q1_2020, Q2_2020, Q3_2020, Q4_2020, Q2020PP
			FROM REQUERIMIENTO_AGREGADO_PREVIO_2;
QUIT;

/*Se Exporta a un excel la salida del requerimiento agregado generada en el paso 25*/
%exportXLS(&BIBLIOTECAOUTPUTS..REQUERIMIENTO_AGREGADO_&FECHAREPORTE, 
			&localProjectPath.&dirSalidasFinales.Requerimiento_Agregado_&FECHAREPORTE,
			Stress_Test);







/**********************SALIDAS ADICIONALES REVISION LOCAL**********************/


/*
&BIBLIOTECAOUTPUTS..REQUERIMIENTO_AGREGADO_&FECHAREPORTE -> 10664
*/

/*Se trata el Instrumento*/		
proc sql;
	create table REQ_AGREGADO_NIVEL_LOCAL_0
	(drop=INSTRUMENTO rename = (INSTRUMENTO_DESC = INSTRUMENTO)) as
		select a.*, b.Descripcion as INSTRUMENTO_DESC
			from &BIBLIOTECAOUTPUTS..REQUERIMIENTO_AGREGADO_&FECHAREPORTE a
				LEFT JOIN &biblioteca..H_Agreg_Local_Instru b
					ON a.INSTRUMENTO = b.Codigo;
quit;

/*Se trata el Producto Prestamos*/	
proc sql;
	create table REQ_AGREGADO_NIVEL_LOCAL_1
	(drop=PROD_PRESTAMOS rename = (PROD_PRESTAMOS_DESC = PROD_PRESTAMOS)) as
		select a.*, b.Descripcion as PROD_PRESTAMOS_DESC
			from REQ_AGREGADO_NIVEL_LOCAL_0 a
				LEFT JOIN &biblioteca..H_Agreg_Local_Prod_Cre b
					ON a.PROD_PRESTAMOS = b.Codigo;
quit;

/*Se trata el Producto Derivados*/
proc sql;
	create table REQ_AGREGADO_NIVEL_LOCAL_2
	(drop=PROD_DERIVADOS rename = (PROD_DERIVADOS_DESC = PROD_DERIVADOS)) as 
		select a.*, b.Descripcion as PROD_DERIVADOS_DESC
			from REQ_AGREGADO_NIVEL_LOCAL_1 a
				LEFT JOIN &biblioteca..H_Agreg_Local_Prod_Deri b
					ON a.PROD_DERIVADOS = b.Codigo;
quit;

/*Se trata el Producto Depositos*/
proc sql;
	create table REQ_AGREGADO_NIVEL_LOCAL_3
	(drop=PROD_DEPOSITOS rename = (PROD_DEPOSITOS_DESC = PROD_DEPOSITOS)) as 
		select a.*, b.Descripcion as PROD_DEPOSITOS_DESC
			from REQ_AGREGADO_NIVEL_LOCAL_2 a
				LEFT JOIN &biblioteca..H_Agreg_Local_Prod_Dep b
					ON a.PROD_DEPOSITOS = b.Codigo;
quit;

/*Se trata el Producto Emisiones*/
proc sql;
	create table REQ_AGREGADO_NIVEL_LOCAL_4
	 (drop=PROD_EMIRF rename = (PROD_EMIRF_DESC = PROD_EMIRF)) as 
		select a.*, b.Descripcion as PROD_EMIRF_DESC
			from REQ_AGREGADO_NIVEL_LOCAL_3 a
				LEFT JOIN &biblioteca..H_Agreg_Local_Prod_Emi b
					ON a.PROD_EMIRF = b.Codigo;
quit;

/*Se trata el Segmento FINREP*/
proc sql;
	create table REQ_AGREGADO_NIVEL_LOCAL_5
	  (drop=SEGMENTO_FINREP rename = (SEGMENTO_FINREP_DESC = SEGMENTO_FINREP)) as 
		select a.*, b.Descripcion as SEGMENTO_FINREP_DESC
			from REQ_AGREGADO_NIVEL_LOCAL_4 a
				LEFT JOIN &biblioteca..H_Agreg_Local_Seg_FINREP b
					ON a.INSTRUMENTO = b.Instrumento AND
						a.SEGMENTO_FINREP = b.Codigo;
quit;

/*Se trata el Tipo Deposito a la Vista*/
proc sql;
	create table REQ_AGREGADO_NIVEL_LOCAL_6
	   (drop=TIPO_DEP_VISTA rename = (TIPO_DEP_VISTA_DESC = TIPO_DEP_VISTA)) as 
		select a.*, b.Descripcion as TIPO_DEP_VISTA_DESC
			from REQ_AGREGADO_NIVEL_LOCAL_5 a
				LEFT JOIN &biblioteca..H_Agreg_Local_Dep_Vista b
					ON a.TIPO_DEP_VISTA = b.Codigo;
quit;

/*Se trata el Indice de Referencia*/
proc sql;
	create table REQ_AGREGADO_NIVEL_LOCAL_7
	    (drop=INDICEREF rename = (INDICEREF_DESC = INDICEREF)) as 
		select a.*, b.Descripcion as INDICEREF_DESC
			from REQ_AGREGADO_NIVEL_LOCAL_6 a
				LEFT JOIN &biblioteca..H_Agreg_Local_IndiRef b
					ON a.INDICEREF = b.Codigo;
quit;

/*Se trata el Plazo de Referencia*/
proc sql;
	create table REQ_AGREGADO_NIVEL_LOCAL_8
	     (drop=PLAZ_REF rename = (PLAZ_REF_DESC = PLAZ_REF)) as 
		select a.*, b.Descripcion as PLAZ_REF_DESC
			from REQ_AGREGADO_NIVEL_LOCAL_7 a
				LEFT JOIN &biblioteca..H_Agreg_Local_Fecha b
					ON a.PLAZ_REF = b.Codigo;
quit;

/*Se trata el Valor Aplicado Referencia*/
proc sql;
	create table REQ_AGREGADO_NIVEL_LOCAL_9
	    (drop=VALREF rename = (VALREF_DESC = VALREF)) as 
		select a.*, b.Descripcion as VALREF_DESC
			from REQ_AGREGADO_NIVEL_LOCAL_8 a
				LEFT JOIN &biblioteca..H_Agreg_Local_Tipo_Int b
					ON a.VALREF = b.Codigo;
quit;

/*Se trata el Valor Spread*/
proc sql;
	create table REQ_AGREGADO_NIVEL_LOCAL_10
	    (drop=VALOR_SPREAD rename = (VALOR_SPREAD_DESC = VALOR_SPREAD)) as 
		select a.*, b.Descripcion as VALOR_SPREAD_DESC
			from REQ_AGREGADO_NIVEL_LOCAL_9 a
				LEFT JOIN &biblioteca..H_Agreg_Local_Tipo_Int b
					ON a.VALOR_SPREAD = b.Codigo;
quit;

/*Se trata el Vencimiento Residual*/
proc sql;
	create table REQ_AGREGADO_NIVEL_LOCAL_11
	     (drop=VTO_RESID rename = (VTO_RESID_DESC = VTO_RESID)) as 
		select a.*, b.Descripcion as VTO_RESID_DESC
			from REQ_AGREGADO_NIVEL_LOCAL_10 a
				LEFT JOIN &biblioteca..H_Agreg_Local_Fecha b
					ON a.VTO_RESID = b.Codigo;
quit;

/*Se trata el Plazo de Repreciacion de la Operacion*/
proc sql;
	create table REQ_AGREGADO_NIVEL_LOCAL_12
	     (drop=PLAZO_REPREC rename = (PLAZO_REPREC_DESC = PLAZO_REPREC)) as 
		select a.*, b.Descripcion as PLAZO_REPREC_DESC
			from REQ_AGREGADO_NIVEL_LOCAL_11 a
				LEFT JOIN &biblioteca..H_Agreg_Local_Reprec b
					ON a.PLAZO_REPREC = b.Codigo;
quit;


/*Se ordenan los campos*/
PROC SQL;
	CREATE TABLE REQ_AGREGADO_NIVEL_LOCAL_13 (EXTENDOBSCOUNTER=NO) AS
		SELECT FECHA_DATOS, ENTIDAD, MARCA_INTER, INSTRUMENTO, PROD_PRESTAMOS, PROD_DERIVADOS, 
				PROD_DEPOSITOS, PROD_EMIRF, SEGMENTO_FINREP, PAIS, DIVISA_OP, TIPO_DEP_VISTA,
				TIPO_FV, INDICEREF, PLAZ_REF, VALREF, VALOR_SPREAD, INDNEWBUS, INDMATBUS, INDOPERVIVA,
				NON_PERFORM, VTO_ORI_PROM, VTO_RESID, PLAZO_REPREC, SALDO_CONTABLE, SALDO_MEDIO,
				PROVISIONES, ING_GAST, Q2016_1_EUR, Q2016_2_EUR, Q2016_3_EUR, Q2016_4_EUR, 
				Q2017_1_EUR, Q2017_2_EUR, Q2017_3_EUR, Q2017_4_EUR, 
				Q1_2018, Q2_2018, Q3_2018, Q4_2018, Q1_2019, Q2_2019, Q3_2019,
				Q4_2019, Q1_2020, Q2_2020, Q3_2020, Q4_2020, Q2020PP
			FROM REQ_AGREGADO_NIVEL_LOCAL_12;
QUIT;

/*Se Exporta a un excel esta salida adicional.
Tiene la misma información que el Requerimiento Agregado, pero en vez de usar
códigos para los valores de los campos, 
se usa su descipción para una mejor visualización*/
%exportXLS(REQ_AGREGADO_NIVEL_LOCAL_13, 
			&localProjectPath.&dirSalidasFinales.Requerimiento_Agregado_Adrian_&FECHAREPORTE,
			Stress_Test);